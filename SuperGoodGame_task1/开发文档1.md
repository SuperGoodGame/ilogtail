# 项目1 过滤插件易用性提升开发文档

## 提供者

[`SuperGoodGame`](https://github.com/SuperGoodGame)

## 过滤表达式语法

#### 语法来源 

  参考SQL中的表达式

#### 语法关键字

```
and or =
```

#### 合法及非法表达式

##### 表达式要求

- 表达式符合括号匹配原则
- 表达式一个原子式为 A=B ，A为key关键字，B为pattern，pattern为对应的正则匹配规则
- 一个子式由两个子式（或两个原子式或一个原子式一个子式）和一个运算符构成
- 表达式运算符，或者连接子式或原子式的符号为and 和 or
- 可以使用小括号
- 原子式中不可以含有空格，原子式与运算符连接时必须用空格隔开，使用括号前后必须用空格隔开
- and优先级高于or

##### 例子

```
//合法的
status=400|500 or level=INFO and msg=.*test.*
( status=400|500 or level=INFO ) and msg=.*test.*
//非法的
status=400|500orlevel=INFOandmsg=.*test.* // 没有空格将原子式与运算符隔开
(status=400|500 or level=INFO) and msg=.*test.* // 没有空格将原子式与括号隔开
400|500=status or level=INFO //等号右边为pattern 左边为key关键字
```

## 代码设计

#### 类图

![](C:\Users\www\Desktop\summar\logtailtask1.jpg)

#### 说明

从需要解析出的json内容可以看出，复杂过滤条件就是一个operator连接两个匹配规则，匹配规则可以嵌套另一个二元过滤条件

从需要实现的功能出发，设计具有二叉树的结构的过滤二叉树， FilterNode类为二叉树的节点，它被两个子类继承，这两类子节点构成过滤二叉树。

* UnLeafNode非叶子节点类，每个非叶子节点对应一个子式，有一个operator和2子节点（表示原子式或子式）
* LeafNode叶子节点类，每个叶子节点类对应一个原子式

col类为实现过滤表达式同现有实现之间的转换的实现类，它包括

* getin 方法读入
* run方法为将读入的式子转化为上述过滤二叉树（formulaFilter为具体递归实现类）
* print 为转化为规定的json输出

#### 实现细节

FilterNode父类定义虚函数print，在具体转化输出时只需要调用不同子类的print函数即可，动态绑定实现多态

用栈来解决运算符优先级问题，用递归调用解决括号问题

构成二叉树核心代码：![ilogtialtask2](C:\Users\www\Desktop\summar\Logtail\ilogtialtask2.jpg)